---
整理：Mr.Chen
原文日期：2025年
更新日期：2025-12-30
原文链接：https://blog.langchain.com/langgraph-multi-agent-workflows/
---

# LangGraph多Agent工作流：从对话到图的范式转变

> 类型：AI工程
> 难度：高级

## 核心问题

**如何设计可控、可观测、可扩展的多Agent系统？**

传统多Agent系统基于对话——Agent之间通过消息交流。LangGraph提出了不同的范式：将Agent系统建模为**图**，用显式的边定义转换，而非依赖对话推断。

## 设计哲学

### 从对话到图

```
对话式多Agent：
Agent A: "我完成了研究，请分析"
Agent B: "好的，分析结果是..."
    ↓
   隐式控制流

图式多Agent：
[研究节点] → [分析节点] → [综合节点]
    ↓
   显式控制流
```

**核心优势**：显式控制"节点之间的转换概率"，而非让LLM决定下一步。

## 三大设计模式

### 模式1：协作模式 (Collaboration)

```
┌─────────────────────────────────────┐
│           共享草稿板                 │
│  [Agent A的输出] [Agent B的输出]    │
└─────────────────────────────────────┘
         ↑               ↑
    ┌────┴────┐     ┌────┴────┐
    │ Agent A │     │ Agent B │
    └─────────┘     └─────────┘
```

**特点**：
- 所有Agent共享工作可见性
- 每个Agent看到其他Agent的步骤
- 适合需要上下文共享的协作

**适用场景**：代码审查、文档协作、问题解决

### 模式2：监督者模式 (Supervisor)

```
        ┌─────────────┐
        │  监督Agent  │
        │ (任务路由)  │
        └──────┬──────┘
               │
    ┌──────────┼──────────┐
    ↓          ↓          ↓
┌───────┐ ┌───────┐ ┌───────┐
│专家A  │ │专家B  │ │专家C  │
│(独立) │ │(独立) │ │(独立) │
└───────┘ └───────┘ └───────┘
```

**特点**：
- 中央Agent负责任务分配
- 专家Agent有独立的草稿板
- 监督者整合结果

**适用场景**：客户服务路由、专家咨询、复杂问答

### 模式3：层级团队模式 (Hierarchical)

```
          ┌─────────────┐
          │  总协调者   │
          └──────┬──────┘
                 │
    ┌────────────┼────────────┐
    ↓            ↓            ↓
┌───────┐   ┌───────┐   ┌───────┐
│团队A  │   │团队B  │   │团队C  │
│LangGraph│  │LangGraph│  │LangGraph│
└───────┘   └───────┘   └───────┘
```

**特点**：
- 嵌套的LangGraph对象
- 多层级Agent结构
- 每个团队是独立的子图

**适用场景**：大型复杂项目、组织级任务、多部门协作

## 底层原理

### 原理1：循环是Agent运行时的核心

```python
while not task_complete:
    action = agent.decide(state)
    result = execute(action)
    state = update(state, result)
```

LangGraph原生支持循环，这是Agent迭代的基础。

### 原理2：状态管理通过边实现

Agent之间通过**状态更新**通信，而非消息：

```python
def research_agent(state):
    # 执行研究
    research_result = do_research(state["query"])
    # 返回状态更新
    return {"research": research_result}

def analysis_agent(state):
    # 读取前一个Agent的输出
    research = state["research"]
    # 执行分析
    return {"analysis": analyze(research)}
```

### 原理3：专业化提升质量

> "将复杂问题分解为可处理的工作单元"

| 通用Agent | 专业化Agent |
|-----------|-------------|
| 一个Agent做所有事 | 每个Agent专注一件事 |
| 提示词复杂 | 提示词简洁 |
| 难以调试 | 独立评估 |
| 能力有限 | 能力可扩展 |

## 实现要点

### LangSmith集成

```
LangGraph → LangSmith
    ↓
 完整追踪
    ↓
 调试 + 评估
```

每个节点的执行都可以被追踪和分析。

### 独立评估

每个Agent可以独立评估：
- 不需要运行整个系统
- 可以针对性优化
- 不会破坏其他Agent

## 最佳实践

### 何时使用多Agent

1. **任务可分解**
   - 明确的子任务边界
   - 可独立评估的输出

2. **专业化有价值**
   - 不同子任务需要不同能力
   - 专家模型比通用模型更优

3. **需要可观测性**
   - 复杂流程需要追踪
   - 需要识别瓶颈

### 何时使用单Agent

- 任务简单直接
- 延迟敏感
- 上下文需要完整共享

### 模式选择指南

| 场景 | 推荐模式 |
|------|----------|
| 需要完整上下文共享 | 协作模式 |
| 任务类型需要路由 | 监督者模式 |
| 大型复杂项目 | 层级团队模式 |

## 设计权衡

| 选择 | 获得 | 牺牲 |
|------|------|------|
| 多Agent | 专业化、可扩展 | 延迟、复杂度 |
| 显式图 | 可控性、可观测性 | 灵活性 |
| 独立草稿板 | 隔离性 | 上下文共享 |

## 关联资源

**📚 相关文档**：
- [LangGraph-状态化Agent编排](./LangGraph-状态化Agent编排.md) - LangGraph基础
- [CrewAI-多Agent协作框架](./CrewAI-多Agent协作框架.md) - 另一种多Agent方法
- [构建有效Agent系统](./构建有效Agent系统.md) - Agent设计原则
